#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: Project Description
#+DATE: <2018-07-01 Sun>
#+AUTHOR: Milo Cress
#+EMAIL: milo@archlinux
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.6)

* TODO Problem
  As computer graphics advance in processing power, the visual detail that graphics processors can render also increases, requiring a larger amount of data to render. The goal of this project is to explore on-the-fly creation of 3-dimensional rendering data, which would limit the amount of data required to render a scene by generating visually relevant areas at a higher level of detail than non-visually relevant areas. While traditional models are stored at a consistent level of detail throughout the scene, this project attempts to create models that comprise only a fraction of the scene, but relative to the viewer, appear to comprise the entire scene.
* TODO Solution Prototype
  This project uses procedural terrain generation that functions on a variety of spatial and temporal scales, at a realistic level of detail. It is divided into two parts: the sector event buffer, and the Sector Tree.
  Implementation of procedural terrain generation with fixed geometries and Levels of Detail, as well as simulation of natural events such as erosion, continental drift, etc.
** Coordinate System
   #+BEGIN_SRC haskell :tangle ./myworld/src/PlanarCoordinate.hs
     module PlanarCoordinate where

     type Scalar = Double

     data PlanarCoordinate = Planar { x_coord :: Scalar
                                    , y_coord :: Scalar } deriving (Show)

     instance Num PlanarCoordinate where
       (Planar a b) + (Planar c d) = Planar (a + c) (b + d)
       (Planar a b) * (Planar c d) = Planar (a * c) (b * d)
       abs (Planar a b) = Planar (abs a) (abs b)
       signum (Planar a b) = Planar (signum a) (signum b)
       fromInteger a = Planar (fromInteger a) 0
       negate (Planar a b) = Planar (-a) (-b)

     newtype Transform = Transform { runTransform :: PlanarCoordinate -> PlanarCoordinate }

     data Sector = Sector { top_left     :: PlanarCoordinate
                          , bottom_right :: PlanarCoordinate } deriving (Show)

     inSector :: Sector -> PlanarCoordinate -> Bool
     inSector (Sector (Planar a b) (Planar c d)) (Planar x y) =
       between_inclusive a c x &&
       between_inclusive d b y

     between_inclusive :: Scalar -> Scalar -> Scalar -> Bool
     between_inclusive bot top x = x >= bot && x <= top

     width :: Sector -> Scalar
     width (Sector (Planar a _) (Planar b _)) = b - a

     height :: Sector -> Scalar
     height (Sector (Planar a _) (Planar b _)) = b - a

     class Transformable a where
       transform :: a -> Transform -> a

     instance Transformable Sector where
       transform (Sector tl br) t = Sector (runTransform t tl) (runTransform t br)

     scale :: Scalar -> Transform
     scale a = Transform $ \(Planar x y) -> Planar (x * a) (y * a)

     translate :: PlanarCoordinate -> Transform
     translate (Planar a b) = Transform $ \(Planar x y) -> Planar (x + a) (y + b)

     mapCoordinates :: Sector -> Sector -> Transform
     mapCoordinates a@(Sector tl _) b@(Sector tl' _) =
       let c = width b / width a
           (Transform f) = translate (-tl)
           (Transform g) = scale c
           (Transform h) = translate tl'
       in Transform $ h .g . f
   #+END_SRC
** Mapping System

   We will use the programming language, Haskell, to prototype our system:

   #+BEGIN_SRC haskell :tangle ./myworld/src/Map.hs
     module Map where
     import PlanarCoordinate
     import Data.Functor.Identity
     import Control.Monad.Trans.Class

     newtype MapT m a = MapT { runMapT :: PlanarCoordinate -> m a }

     instance Functor m => Functor (MapT m) where
       fmap f x = MapT $ \p -> fmap f ( runMapT x p )

     instance Applicative m => Applicative (MapT m) where
       f <*> x = MapT $ \p -> runMapT f p <*> runMapT x p
       pure  x = MapT $ \_ -> pure x

     instance Monad m => Monad (MapT m) where
       (>>=)  = bind
       return = unit

     bind :: Monad m => MapT m a -> (a -> MapT m b) -> MapT m b
     bind x f = MapT $ \p -> do
       pointAttr <- runMapT x p
       runMapT ( f pointAttr ) p

     unit :: Monad m => a -> MapT m a
     unit x = MapT $ \_ -> return x

     instance (Applicative m, Num a) => Num (MapT m a) where
       a + b = (+) <$> a <*> b
       a - b = (-) <$> a <*> b
       a * b = (*) <$> a <*> b
       abs a = abs <$> a
       signum a = signum <$> a
       fromInteger = pure . fromInteger

     instance MonadTrans MapT where
       lift = MapT . const

     type Height = Double
     type Heightmap = Map Height
     type Map = MapT Identity

     runMap :: Map a -> PlanarCoordinate -> a
     runMap m p = runIdentity (runMapT m p)

   #+END_SRC

   #+BEGIN_SRC haskell :tangle ./myworld/src/MapExamples.hs
      {-# LANGUAGE LambdaCase #-}
      module MapExamples where

      import PlanarCoordinate
      import Map

      -- This is a map which returns "Nothing" if a coordinate is out of bounds,
      -- or "Just a" if a coordinate is in bounds.
      type MaybeHeightmap = MapT Maybe Height

      flatMap :: MaybeHeightmap
      flatMap = return 1.0

      -- The unit declaration above is synonymous with the following, but more readable (and therefore preferred):
      -- flatMap = Map $ \_ -> Just 1.0

      -- Any calls to getPointAttr of flatMap will return 1.0 -- this is the most basic and simple kind of map.
      -- Ex:
      -- getPointAttr flatMap $ Planar 1 2
      -- getPointAttr flatMap $ Planar Infinity 0
      -- As we can see, unit declarations don't sanity-check inputs, but don't need to. They can take any input.

      bumpyMap :: MaybeHeightmap
      bumpyMap = MapT $ \case
        Planar x y -> Just $ sin x * cos y

      -- DEPRECATED:
      -- Note that since bumpyMap works around the Maybe monad, it's possible for the function to fail, such as when
      -- it's applied to a coordinate that is non-planar.
      -- Richer monadic wrappers can result in more expressive error messages, such as (Left "spherical coordinates not
      -- supported" -- a result of the Either monad).
      type MaybeHeightmap' = MapT (Either String) Height

      bumpyMap' :: MaybeHeightmap'
      bumpyMap' = MapT $ \case
        Planar x y -> Right $ sin x * cos y
     -- _          -> Left "Spherical coordinates not supported"
        -- Since the most recent revision (at time of writing), spherical coordinates are a different data type than planar coordinates.
        -- This code remains because it is a good example of the use of various underlying monads for Maps.

      -- Now, we can use monadic binding to compose maps! Yay!
      flatAndBumpy :: MaybeHeightmap
      flatAndBumpy = do
        h  <- flatMap
        h' <- bumpyMap
        return $ h + h'
      -- This is remarkably compact syntax compared to a non-monadic style, and forms the basis for the implementation
      -- of the Num typeclass (the Num implementation has since been rewritten to use the more succinct Applicative
      -- syntax, but it is easy to imagine how Num could be written with monads).

      -- instance (Monad m, Num a) => Num (MapT m a) where
      --   a + b = do
      --     v  <- a
      --     v' <- b
      --     return $ v + v'
      --   ...
      --   abs a = do
      --     v <- a
      --     return $ abs v
      --   fromInteger = return . fromInteger

      -- As a matter of fact, now that arithmetic is implemented for Maps, it's much simpler to define flatAndBumpy:
      flatAndBumpy' :: MaybeHeightmap
      flatAndBumpy' = flatMap + bumpyMap

      -- These expressions become even more powerful when used to transform types. For example, imagine that a
      -- topographical map (hMap :: heightmap), a roughness map (rMap :: MapT Maybe Double), and a wetmap (wMap :: MapT
      -- Maybe Bool) are to be displayed by a program as an image, using the red, green, and blue channels to indicate
      -- elevation, roughness, and water distribution, respectively. A simple color library exists which has the type
      -- constructor:
      -- RGB :: Double -> Double -> Double -> Color
      data Color = RGB { red :: Double, blue :: Double, green :: Double }
      -- In order to display the map, we need to convert the heightmap to a Color map.
      type Colormap = Map Color
      -- We can use monads for this!
      toColorMap :: Heightmap -> Map Double -> Map Bool -> Colormap
      toColorMap hMap rMap wMap = do
        height    <- hMap
        roughness <- rMap
        wetness   <- wMap
        let w_val = if wetness then 1 else 0
          in return $ RGB height roughness w_val

      -- We can also use applicatives.
      toColorMap' :: Heightmap -> Map Double -> Map Bool -> Colormap
      toColorMap' hMap rMap wMap = RGB <$> hMap <*> rMap <*> fmap (\x -> if x then 1 else 0) wMap
      -- While the monadic version is the more readable of the two (but not by a large margin), the applicative version
      -- is far more succinct. At this point it's debatable which style to use. I believe that for calculations which
      -- require a great deal of nested unwrapping, composition, and/or mapping, a monadic style is appropriate.
      -- For simpler calculations (such as the one above) which are more a matter of applying a function to the value
      -- contained by a monad rather than to the monad itself (with minimal nesting such as the if-else block), the
      -- applicative style is cleaner.

      -- On the other hand, complex calculations, which "require a great deal of nested unwrapping, composition, and/or"
      -- mapping, can be composed of simpler applicative-style functions. I'm honestly not sure what the monadic style is
      -- useful for at this point, but it's implementation will be preserved in case I think of something.


      -- Consider this function, runMaybeMap, to be a precursor to Layer addition of SectorMaps.
      runMaybeMap :: MapT Maybe a -> a -> PlanarCoordinate -> a
      runMaybeMap m failval = runMap . MapT $ \p ->
        case runMapT m p of
          Just x  -> return x
          Nothing -> return failval

      -- Another nice thing is that we can implement custom logic to change the underlying monad of a MapT (or map for
      -- that matter) (See above)

   #+END_SRC

** Bounded Maps
   #+BEGIN_SRC haskell :tangle ./myworld/src/SectorMap.hs
     module SectorMap where

     import Map
     import PlanarCoordinate

     type SectorMap a = MapT Maybe a

     runSectorMap :: SectorMap a -> PlanarCoordinate -> Maybe a
     runSectorMap = runMapT

     -- Non-strict Map addition
     (<+>) :: (Functor m, Num a) => MapT m a -> SectorMap a -> MapT m a
     bot <+> top = MapT $ \p ->
       case runSectorMap top p of
         Nothing -> runMapT bot p
         Just x  -> (+x) <$> runMapT bot p

     -- Non-strict Map overlaying
     (>>>) :: (Applicative m) => MapT m a -> SectorMap a -> MapT m a
     bot >>> top = MapT $ \p ->
       case runSectorMap top p of
         Nothing -> runMapT bot p
         Just x  -> pure x

     fromMap :: Map a -> Sector -> SectorMap a
     fromMap m s = MapT $ \p ->
       if inSector s p
       then Just $ runMap m p
       else Nothing

     toMap :: SectorMap a -> a -> Map a
     toMap m failval = return failval >>> m
   #+END_SRC
** ArrayMaps
   #+BEGIN_SRC haskell :tangle ./myworld/src/ArrayMap.hs
     module ArrayMap where

     import Data.Array.Repa
     import qualified Data.Vector.Unboxed as U

     import Map
     import SectorMap
     import PlanarCoordinate
     import Resolution

     type ArrayMap a = SectorMap a

     runArrayMap :: ArrayMap a -> PlanarCoordinate -> Maybe a
     runArrayMap = runSectorMap

     fromArray :: U.Unbox a => Array U DIM2 a -> ArrayMap a
     fromArray arr =
       let (Z :. a :. b) = extent arr
       in fromMap (MapT $ \(Planar x y) -> return $ arr ! (Z :. floor x :. floor y)) (resToSector $ Resolution a b)
   #+END_SRC
** TODO Maps to Images
   #+BEGIN_SRC haskell :tangle ./myworld/src/Resolution.hs
     module Resolution where

     import PlanarCoordinate 

     data Resolution = Resolution { image_width  :: Int
                                  , image_height :: Int} deriving (Show)

     resToSector :: Resolution -> Sector
     resToSector (Resolution x y) = Sector
                                    (Planar 0 (fromIntegral y))
                                    (Planar (fromIntegral x) 0)
   #+END_SRC

   #+BEGIN_SRC haskell :tangle ./myworld/src/PixelMap.hs
     module PixelMap where

     import Codec.Picture.Types
     import Data.Functor.Identity

     import Map
     import PlanarCoordinate
     import Resolution

     type PixelMap = Map PixelRGB8

     fromPixelMap :: PixelMap -> Resolution -> Image PixelRGB8
     fromPixelMap m (Resolution w h) = generateImage (\x y -> runMap m $ Planar (fromIntegral x) (fromIntegral y)) w h
     -- f is a constructor for PlanarCoordinate.
   #+END_SRC

   #+BEGIN_SRC haskell :tangle ./myworld/src/ImageExamples.hs
     module ImageExamples where

     import PixelMap
     import Map
     import PlanarCoordinate
     import Codec.Picture.Types
     import Codec.Picture
     import Data.Complex

     gradient :: PixelMap
     gradient = MapT $ \(Planar x y) -> return $ PixelRGB8 (mod (floor x) 255) (mod (floor y) 255) 255

     m_mand :: PixelMap
     m_mand = mandelmap 1000 $ Transform $ \(Planar x y) -> Planar (x / 600 - 2) (y / 600 - (1080/1200))

     mandelmap :: Int -> Transform -> PixelMap
     mandelmap n xform = MapT $ \p -> return $
       let (Planar x y) = runTransform xform p
           z            = x :+ y
       in if mandelbrot z z n then black else white
       -- Note that this is the OLD way of creating an image, and is not considered best practice. For modern
       -- image examples, refer to RepaExamples.
       -- This file is preserved mainly for legacy purposes, and the code contained here is slower and more
       -- naive than in other files.

     mandelbrot :: Complex Double -> Complex Double -> Int -> Bool
     mandelbrot z _ _ | (sqr $ realPart z) + (sqr $ imagPart z) > 4 = False where sqr a = a * a
     mandelbrot _ _ i | i <= 0 = True
     mandelbrot z c i = mandelbrot (z*z + c) c (i - 1)

     black :: PixelRGB8
     black = PixelRGB8 0 0 0

     white :: PixelRGB8
     white = PixelRGB8 255 255 255
   #+END_SRC
** Repa
   #+BEGIN_SRC haskell :tangle ./myworld/src/RGBMap.hs
     module RGBMap where

     import Codec.Picture.Types
     import Data.Array.Repa
     import Data.Functor.Identity

     import Map
     import PlanarCoordinate
     import Resolution

     type RGB8   = (Pixel8, Pixel8, Pixel8)
     type RGBMap = Map RGB8

     toPixel :: RGB8 -> PixelRGB8
     toPixel (r, g, b) = PixelRGB8 r g b

     fromRGBMap :: RGBMap -> Resolution -> Image PixelRGB8
     fromRGBMap  m r = fromArrToImg . unboxArr $ fromMapToArr m r

     unboxArr :: Array D DIM2 RGB8 -> Array U DIM2 RGB8
     unboxArr = runIdentity . computeUnboxedP

     fromMapToArr :: RGBMap -> Resolution -> Array D DIM2 RGB8
     fromMapToArr m (Resolution w h) = fromFunction (Z :. w :. h) $ \(Z :. x :. y) ->
       runMap m $ Planar (fromIntegral x) (fromIntegral y)

     fromArrToImg :: Array U DIM2 RGB8 -> Image PixelRGB8
     fromArrToImg a =
       let (Z :. w :. h) = extent a
       in generateImage (\x y -> toPixel $ a ! (Z :. x :. y)) w h
   #+END_SRC

   #+BEGIN_SRC haskell :tangle ./myworld/src/RepaExamples.hs
     module RepaExamples where

     import Codec.Picture.Types
     import Codec.Picture
     import Data.Complex

     import RGBMap
     import Map
     import PlanarCoordinate
     import Resolution

     data XYR = XYR { xyr_x :: Double, xyr_y :: Double, xyr_r :: Double }
     xyrToSector :: XYR -> Sector
     xyrToSector (XYR x y r) = Sector (Planar (x - r) (y + r)) (Planar (x + r) (y - r))

     mandelbrot :: Complex Double -> Complex Double -> Int -> Bool
     mandelbrot z _ _ | (sqr $ realPart z) + (sqr $ imagPart z) > 4 = False where sqr a = a * a
     mandelbrot _ _ 0 = True
     mandelbrot z c i = mandelbrot (z*z + c) c (i - 1)

     mandelmap' :: Int -> XYR -> Resolution -> RGBMap
     mandelmap' n xyr r =
       let mandSector = xyrToSector xyr
           imgSector  = resToSector r
           xform      = mapCoordinates imgSector mandSector
       in  MapT $ \p -> return $
         let (Planar x y) = runTransform xform p
             z            = x :+ y
         in if mandelbrot z z n then black' else white'

     black' :: RGB8
     black' = (0, 0, 0)

     white' :: RGB8
     white' = (255, 255, 255)

     saveMandelimg :: String -> Int -> XYR -> Resolution -> IO ()
     saveMandelimg fp n xyr r = savePngImage fp . ImageRGB8 $ fromRGBMap (mandelmap' n xyr r) r
   #+END_SRC
** TODO Sector Tree
   Implementation of a =SectorTree=, along with code that divides sectors into smaller child sectors, as well as control code that decides how/when to expand or prune branches of the sector tree.
   #+BEGIN_SRC haskell
   #+END_SRC

** Stack Setup
   #+BEGIN_SRC haskell :tangle ./myworld/app/Main.hs
     module Main where

     import Codec.Picture
     import System.Environment

     import PlanarCoordinate
     import RGBMap
     import RepaExamples
     import Resolution

     file :: String
     file = "./map.png"

     main :: IO ()
     -- main = savePngImage file . ImageRGB8 $ fromPixelMap m_mand 1920 1080
     main = do
       args <- getArgs
       let x = read $ args !! 0
           y = read $ args !! 1
           r = read $ args !! 2
           n = read $ args !! 3
           w = read $ args !! 4
           h = read $ args !! 5
           f = read $ args !! 6
         in saveMandelimg f n (XYR x y r) (Resolution w h)
     -- X = -0.16
     -- Y = 1.0405
     -- R = 0.026
   #+END_SRC

